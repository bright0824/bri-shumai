/// <reference types="bun-types" />
import { FFIType } from 'bun:ffi';
declare const ffi_tensor_ops: {
    _rand: {
        args: FFIType[];
        returns: FFIType;
    };
    _randn: {
        args: FFIType[];
        returns: FFIType;
    };
    _full: {
        args: FFIType[];
        returns: FFIType;
    };
    _identity: {
        args: FFIType[];
        returns: FFIType;
    };
    _arange: {
        args: FFIType[];
        returns: FFIType;
    };
    _iota: {
        args: FFIType[];
        returns: FFIType;
    };
    _reshape: {
        args: FFIType[];
        returns: FFIType;
    };
    _transpose: {
        args: FFIType[];
        returns: FFIType;
    };
    _tile: {
        args: FFIType[];
        returns: FFIType;
    };
    _concatenate: {
        args: FFIType[];
        returns: FFIType;
    };
    _nonzero: {
        args: FFIType[];
        returns: FFIType;
    };
    _negative: {
        args: FFIType[];
        returns: FFIType;
    };
    _logicalNot: {
        args: FFIType[];
        returns: FFIType;
    };
    _exp: {
        args: FFIType[];
        returns: FFIType;
    };
    _log: {
        args: FFIType[];
        returns: FFIType;
    };
    _log1p: {
        args: FFIType[];
        returns: FFIType;
    };
    _sin: {
        args: FFIType[];
        returns: FFIType;
    };
    _cos: {
        args: FFIType[];
        returns: FFIType;
    };
    _sqrt: {
        args: FFIType[];
        returns: FFIType;
    };
    _tanh: {
        args: FFIType[];
        returns: FFIType;
    };
    _floor: {
        args: FFIType[];
        returns: FFIType;
    };
    _ceil: {
        args: FFIType[];
        returns: FFIType;
    };
    _rint: {
        args: FFIType[];
        returns: FFIType;
    };
    _absolute: {
        args: FFIType[];
        returns: FFIType;
    };
    _sigmoid: {
        args: FFIType[];
        returns: FFIType;
    };
    _erf: {
        args: FFIType[];
        returns: FFIType;
    };
    _flip: {
        args: FFIType[];
        returns: FFIType;
    };
    _clip: {
        args: FFIType[];
        returns: FFIType;
    };
    _roll: {
        args: FFIType[];
        returns: FFIType;
    };
    _isnan: {
        args: FFIType[];
        returns: FFIType;
    };
    _isinf: {
        args: FFIType[];
        returns: FFIType;
    };
    _sign: {
        args: FFIType[];
        returns: FFIType;
    };
    _tril: {
        args: FFIType[];
        returns: FFIType;
    };
    _triu: {
        args: FFIType[];
        returns: FFIType;
    };
    _where: {
        args: FFIType[];
        returns: FFIType;
    };
    _sort: {
        args: FFIType[];
        returns: FFIType;
    };
    _add: {
        args: FFIType[];
        returns: FFIType;
    };
    _sub: {
        args: FFIType[];
        returns: FFIType;
    };
    _mul: {
        args: FFIType[];
        returns: FFIType;
    };
    _div: {
        args: FFIType[];
        returns: FFIType;
    };
    _eq: {
        args: FFIType[];
        returns: FFIType;
    };
    _neq: {
        args: FFIType[];
        returns: FFIType;
    };
    _lessThan: {
        args: FFIType[];
        returns: FFIType;
    };
    _lessThanEqual: {
        args: FFIType[];
        returns: FFIType;
    };
    _greaterThan: {
        args: FFIType[];
        returns: FFIType;
    };
    _greaterThanEqual: {
        args: FFIType[];
        returns: FFIType;
    };
    _logicalOr: {
        args: FFIType[];
        returns: FFIType;
    };
    _logicalAnd: {
        args: FFIType[];
        returns: FFIType;
    };
    _mod: {
        args: FFIType[];
        returns: FFIType;
    };
    _bitwiseAnd: {
        args: FFIType[];
        returns: FFIType;
    };
    _bitwiseOr: {
        args: FFIType[];
        returns: FFIType;
    };
    _bitwiseXor: {
        args: FFIType[];
        returns: FFIType;
    };
    _lShift: {
        args: FFIType[];
        returns: FFIType;
    };
    _rShift: {
        args: FFIType[];
        returns: FFIType;
    };
    _minimum: {
        args: FFIType[];
        returns: FFIType;
    };
    _maximum: {
        args: FFIType[];
        returns: FFIType;
    };
    _power: {
        args: FFIType[];
        returns: FFIType;
    };
    _matmul: {
        args: FFIType[];
        returns: FFIType;
    };
    _conv2d: {
        args: FFIType[];
        returns: FFIType;
    };
    _amin: {
        args: FFIType[];
        returns: FFIType;
    };
    _amax: {
        args: FFIType[];
        returns: FFIType;
    };
    _argmin: {
        args: FFIType[];
        returns: FFIType;
    };
    _argmax: {
        args: FFIType[];
        returns: FFIType;
    };
    _sum: {
        args: FFIType[];
        returns: FFIType;
    };
    _cumsum: {
        args: FFIType[];
        returns: FFIType;
    };
    _mean: {
        args: FFIType[];
        returns: FFIType;
    };
    _median: {
        args: FFIType[];
        returns: FFIType;
    };
    _var: {
        args: FFIType[];
        returns: FFIType;
    };
    _std: {
        args: FFIType[];
        returns: FFIType;
    };
    _norm: {
        args: FFIType[];
        returns: FFIType;
    };
    _countNonzero: {
        args: FFIType[];
        returns: FFIType;
    };
    _any: {
        args: FFIType[];
        returns: FFIType;
    };
    _all: {
        args: FFIType[];
        returns: FFIType;
    };
};
export { ffi_tensor_ops };
