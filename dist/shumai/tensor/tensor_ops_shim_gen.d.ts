import type { Tensor } from './tensor';
export declare const gen_tensor_op_shim: (_Tensor: new (...args: unknown[]) => Tensor) => {
    reshape(shape: BigInt64Array | number[]): Tensor;
    transpose(axes: BigInt64Array | number[]): Tensor;
    tile(shape: BigInt64Array | number[]): Tensor;
    nonzero(): Tensor;
    negative(): Tensor;
    negate(): any;
    logicalNot(): Tensor;
    exp(): Tensor;
    log(): Tensor;
    log1p(): Tensor;
    sin(): Tensor;
    cos(): Tensor;
    sqrt(): Tensor;
    tanh(): Tensor;
    floor(): Tensor;
    ceil(): Tensor;
    rint(): Tensor;
    absolute(): Tensor;
    abs(): any;
    sigmoid(): Tensor;
    erf(): Tensor;
    flip(dim: number): Tensor;
    clip(low: Tensor, high: Tensor): Tensor;
    roll(shift: number, axis: number): Tensor;
    isnan(): Tensor;
    isinf(): Tensor;
    sign(): Tensor;
    tril(): Tensor;
    triu(): Tensor;
    where(x: Tensor, y: Tensor): Tensor;
    sort(dim: number): Tensor;
    add(tensor: Tensor): Tensor;
    sub(tensor: Tensor): Tensor;
    mul(tensor: Tensor): Tensor;
    div(tensor: Tensor): Tensor;
    eq(tensor: Tensor): Tensor;
    neq(tensor: Tensor): Tensor;
    lessThan(tensor: Tensor): Tensor;
    lt(tensor: Tensor): any;
    lessThanEqual(tensor: Tensor): Tensor;
    lte(tensor: Tensor): any;
    greaterThan(tensor: Tensor): Tensor;
    gt(tensor: Tensor): any;
    greaterThanEqual(tensor: Tensor): Tensor;
    gte(tensor: Tensor): any;
    logicalOr(tensor: Tensor): Tensor;
    logicalAnd(tensor: Tensor): Tensor;
    mod(tensor: Tensor): Tensor;
    bitwiseAnd(tensor: Tensor): Tensor;
    bitwiseOr(tensor: Tensor): Tensor;
    bitwiseXor(tensor: Tensor): Tensor;
    lShift(tensor: Tensor): Tensor;
    rShift(tensor: Tensor): Tensor;
    minimum(tensor: Tensor): Tensor;
    maximum(tensor: Tensor): Tensor;
    power(tensor: Tensor): Tensor;
    matmul(tensor: Tensor): Tensor;
    mm(tensor: Tensor): any;
    conv2d(weights: Tensor, sx?: number, sy?: number, px?: number, py?: number, dx?: number, dy?: number, groups?: number): Tensor;
    amin(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    amax(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    argmin(axis: number, keep_dims?: boolean): Tensor;
    argmax(axis: number, keep_dims?: boolean): Tensor;
    sum(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    cumsum(axis: number): Tensor;
    mean(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    median(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    _var(axes?: BigInt64Array | number[], bias?: boolean, keep_dims?: boolean): Tensor;
    variance(axes?: BigInt64Array | number[], bias?: boolean, keep_dims?: boolean): any;
    std(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    norm(axes?: BigInt64Array | number[], p?: number, keep_dims?: boolean): Tensor;
    normalize(axes?: BigInt64Array | number[], p?: number, keep_dims?: boolean): any;
    countNonzero(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    any(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
    all(axes?: BigInt64Array | number[], keep_dims?: boolean): Tensor;
};
